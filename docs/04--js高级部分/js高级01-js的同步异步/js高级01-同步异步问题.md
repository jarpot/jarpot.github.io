# 第一章：进程，线程，同步任务，异步任务

## 课前测试：

## 回顾：

## 本章目标 

- 理解什么是线程进程
- 理解什么是任务队列
- 理解什么是同步任务和异步任务 
- 理解Event Loop (事件循环)
- 掌握js执行机制 

## 一、进程和线程  

并发  高并发(线程安全问题)。====》服务器端。

web 服务器

计划赶不上变化。

但凡是软件开发，必须要考虑高并发问题。

危机预案：出现问题的时候的应急方案，解决突发问题。

我们只能根据市场调研 尽可能的减少问题的产生，但是不能完全解决！！！

var  tickets = 1000;  数据安全性。

if(tickets>0){

​		ticktes--;

}

### 1.1 线程与进程 

**进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位**

进程：cpu为程序分配的内存资源

线程：用来执行代码的。

* **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

* **线程**：**线程是进程中的一个执行单元**，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 

  **主线程：** 一个进程中只有一个线程执行代码。 main

  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 ，至少有一个线程


核心CPU : 中央处理器  单核单线程 

**在开销方面：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**所处环境：**在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

**内存分配方面：**系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

**包含关系：**没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：

**进程**

![](https://gitee.com/Yawpot/cloudimages/raw/master/img/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png)

**线程**

![](https://gitee.com/Yawpot/cloudimages/raw/master/img/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png)

## 二、浏览器内核模块组成 

浏览器中的某**一个**网页  是单线程的。

* 主线程(执行栈)   同步任务

  * js引擎模块 : 负责 js 程序的编译与运行  var a =  4;
  * html,css文档解析模块 : 负责页面文本的解析   < h1>< /h1>
  * DOM/CSS模块 : 负责dom/css在内存中的相关处理   divEle    . style  (样式对象).
  * 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)

* 分线程(任务队列)  异步任务

  * 定时器模块 : 负责定时器的管理
  * DOM事件模块 : 负责事件的管理
  * 网络请求模块 : 负责Ajax请求


此处划分的主线程和分线程  是 由 js代码模拟出来的线程，并不是真正的多线程。

* #### 定时器问题: 

  * 定时器真的是完全定时执行的吗？  

    定时器并不能保证完全定时执行，一般会有一些延迟。

  * 定时器的回调函数是在分线程执行的吗？

    是在主线程执行的，js是单线程的。

  * 定时器是如何实现的？

    事件循环模型

## JavaScript线程

#### 代码分类：

js中代码的执行可以分为两类：

​		初始化代码(同步任务代码)

​		回调函数：

​		回调代码(异步任务代码)

### 为什么js是单线程？

- JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

- JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

  线程安全问题！！！===》数据的安全性(多个线程同时对**一个数据**进行**不同的操作**，那到底以哪个线程伪准呢？)。

- 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

## 同步任务，异步任务  

- `Javascript` 有一个 `main thread` 主线程和 `call-stack` 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。
- 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
- 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备/用户的读写操作）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。
- JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
- 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在**主线程**上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务。
- JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

### 经典面试问题

问：js为什么需要异步?
答：如果JS中不存在异步,只能自上而下执行,万一上一行解析时间很长,那么下面的代码就 会被阻塞。对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验。 
问： js单线程又是如何实现异步的呢?
答：通过事件循环(event loop)实现'异步'。 
问： 异步任务有哪些呢？ 
答：定时函数setTimeout和setInterval; DOM事件绑定;图片，视频，音频的加载， 回调函数，Ajax操作; NodeJS中的fs文件读写 等。

问：同步任务有哪些？

 正常的js代码块，页面结构骨架的搭建，标签，样式，解析等都是同步任务

![image-20210705235105983](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20210705235105983.png)

## 三、Event Loop 事件循环 

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

![image-20211127112626700](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20211127112626700.png)

![image-20211126123357821](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20211126123357821.png)

![image-20211127165346525](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20211127165346525.png)



1. 执行栈
	execution stack
	所有的代码都是在此空间中执行的
	
2. 浏览器内核
	browser core
	js引擎模块(在主线程处理)
	其它模块(在主/分线程处理)
	
3. 任务队列
	task queue
	
4. 消息队列
	message queue                             callback  queue  回调队列
	
5. 事件队列
	event queue
	
6. 事件轮询
	event loop
	从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)
	
7. 事件驱动模型
	event-driven interaction model
	
8. 请求响应模型 
	request请求 - response响应 model
同一个: callback queue
	
	请求就是通过浏览器向服务器发送一个请求(就是 URL: 协议+ip地址+端口号+资源路径+参数+锚点(可选))
	
	不管请求是否成功 我们客户端都会得到一个响应：
	
	​		如果成功了：我们可以直接从服务器得到我们需要的数据信息
	
	​		如果失败了：我们可以拿到错误的提示信息。
	
	​				200  成功
	
	​				404  路径错误，跟后台无关。
	
	​				500  服务器内部错误，请联系后端开发者解决！！！

### 代码分析 



![image-20210705235210915](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20210705235210915-1637987756683.png)

![image-20210705235215581](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20210705235215581-1637987756684.png)

![image-20210705235220249](https://gitee.com/Yawpot/cloudimages/raw/master/img/image-20210705235220249-1637987756684.png)

```
1）回调函数（回调函数就是将一个函数当作另一个主函数的参数来使用的函数。）

这是异步编程最基本的方法

需求：
假定有两个函数 test1 和 test2，后者等待前者的执行结果。
如果test1()是一个比较耗时的任务，就会把test1放入任务队列中，先执行test2的代码，这样test2需要的变量会报错undfind；所以可以考虑改写test1()，把test2()写成test1()的回调函数
改写如下：

function test1(callback){ //(主函数)
   console.log('执行了test1');  //主函数任务代码
　 setTimeout(function () {
　　 callback();
　　}, 1000);
}
function test2(){//回调函数
   console.log('执行了test2');
}

test1(test2); // 执行

//改版

		var a = 0;
        function test1(b) {
            console.log("test1执行");
            setTimeout(function () {
                a += 5;
                b();
                console.log(1111);
            }, 1000);
        }
        function test2() {
            console.log("test2:" + a);
        }

        //需求：让test2中输出的a必须是 test1处理过的a的值

        test1(test2);
       // test2();

解读：
回调函数是传统的一种异步编程解决方案，其原理就是将一个函数当作参数传递到另一个主函数中，当主函数执行完自身的内容之后，在运行传递进来的回调函数。

采用这种方式，我们把同步操作变成了异步操作，test1()不会堵塞程序运行，相当于先执行主程序的主要逻辑，将耗时的操作推迟执行。

优点：简单，容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱
缺点：一个任务只能有一个回调函数
```



## 四、总结与作业 

内核  Trident IE专用内核   安全性较高----》一般来说  政府部门网站，银行网站使用 IE浏览器居多。 私服

占有率 chrom 百分之六七十

火狐和IE(edge)

总结：今日所有内容

​		进程与线程

​		浏览器的内核（内部的模块）

**背就完事了！！！** 

周末时间：

​		预习：json   ajax 